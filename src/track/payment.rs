// Raider
//
// Affiliates dashboard
// Copyright: 2018, Valerian Saliou <valerian@valeriansaliou.name>
// License: Mozilla Public License v2.0 (MPL v2.0)

use std::thread;
use log;
use chrono::offset::Utc;
use diesel;
use diesel::prelude::*;
use separator::FixedPlaceSeparatable;
use num_traits::ToPrimitive;
use bigdecimal::BigDecimal;

use notifier::email::EmailNotifier;
use exchange::manager::normalize as exchange_normalize;
use storage::schemas::tracker::dsl::{tracker, id as tracker_id};
use storage::schemas::account::dsl::account;
use storage::schemas::balance::dsl::{balance, amount as balance_amount,
                                     currency as balance_currency, trace as balance_trace,
                                     account_id as balance_account_id,
                                     tracker_id as balance_tracker_id,
                                     created_at as balance_created_at,
                                     updated_at as balance_updated_at};
use storage::models::{Account, Tracker};
use storage::db::DbConn;
use APP_CONF;

pub enum HandlePaymentError {
    InvalidAmount,
    BadCurrency,
    NotFound,
}

pub fn handle_payment(
    db: &DbConn,
    tracking_id: &str,
    amount_real: f32,
    currency: &str,
    trace: &Option<String>,
) -> Result<Option<(bool, String, String, f32, String)>, HandlePaymentError> {
    log::debug!(
        "payment handle: {} of real amount: {} {}",
        tracking_id,
        currency,
        amount_real
    );

    // Normalize amount
    if let Ok(amount) = exchange_normalize(amount_real, currency) {
        log::debug!(
            "normalized real amount: {} {} to: {} {}",
            currency,
            amount_real,
            &APP_CONF.payout.currency,
            amount
        );

        // Validate amount
        if amount < 0.00 {
            return Err(HandlePaymentError::InvalidAmount);
        }

        // Ignore zero amount
        if amount == 0.00 {
            return Ok(None);
        }

        // Resolve user for tracking code
        let track_result = tracker
            .filter(tracker_id.eq(tracking_id))
            .inner_join(account)
            .first::<(Tracker, Account)>(&**db);

        if let Ok(track_inner) = track_result {
            // Apply user commission percentage to amount
            let commission_amount = amount * track_inner.1.commission.to_f32().unwrap_or(0.0);

            if commission_amount > 0.0 {
                let now_date = Utc::now().naive_utc();

                let insert_result = diesel::insert_into(balance)
                    .values((
                        &balance_amount.eq(BigDecimal::from(commission_amount)),
                        &balance_currency.eq(&APP_CONF.payout.currency),
                        &balance_trace.eq(trace),
                        &balance_account_id.eq(&track_inner.1.id),
                        &balance_tracker_id.eq(&track_inner.0.id),
                        &balance_created_at.eq(&now_date),
                        &balance_updated_at.eq(&now_date),
                    ))
                    .execute(&**db);

                if insert_result.is_ok() == true {
                    return Ok(Some((
                        track_inner.1.notify_balance,
                        track_inner.1.email.to_owned(),
                        track_inner.0.id.to_owned(),
                        commission_amount,
                        APP_CONF.payout.currency.to_owned(),
                    )));
                }
            }
        }

        log::warn!(
            "payment: {} could not be stored to balance for amount: {} {}",
            tracking_id,
            currency,
            amount
        );

        Err(HandlePaymentError::NotFound)
    } else {
        Err(HandlePaymentError::BadCurrency)
    }
}

pub fn run_notify_payment(
    user_email: String,
    source_tracker_id: String,
    commission_amount: f32,
    commission_currency: String,
) {
    thread::spawn(move || {
        dispatch_notify_payment(
            user_email,
            source_tracker_id,
            commission_amount,
            commission_currency,
        );
    });
}

fn dispatch_notify_payment(
    user_email: String,
    source_tracker_id: String,
    commission_amount: f32,
    commission_currency: String,
) {
    // Generate message
    let mut message = String::new();

    message.push_str("Hi,\n\n");

    message.push_str(&format!(
        "You just received commission money of {} {} on your affiliates account balance.\n",
        &commission_currency,
        &commission_amount.separated_string_with_fixed_place(2)
    ));

    message.push_str(&format!(
        "This commission was generated by your tracker with ID: {}\n\n",
        &source_tracker_id
    ));

    message.push_str(
        "You can request for a payout anytime on your dashboard (payouts are not automatic).",
    );

    // Send email
    if EmailNotifier::dispatch(
        &user_email,
        "You received commission money".to_string(),
        &message,
    ).is_ok() == true
    {
        log::debug!(
            "sent balance commission notification email to user on: {}",
            user_email
        );
    } else {
        log::error!(
            "could not send balance commission notification email to user on: {}",
            user_email
        );
    }
}
